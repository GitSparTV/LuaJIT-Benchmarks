<html>
	<head>
		<link href="https://fonts.googleapis.com/css?family=Roboto|Ubuntu+Mono&display=swap" rel="stylesheet">
		<title>LuaJIT Benchmark Tests</title>
		<meta name="description" content="LuaJIT Benchmark tests page. Made for understanding the results and for optimization solutions.">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="keywords" content="Lua, LuaJIT, benchmark, benchmark tests, performance, LuaJIT vs Lua, LuaJIT performance, Lua performance">
		<script src="toc.js" type="text/javascript"></script>
		<style type="text/css">
			body {
				font-family: 'Roboto', sans-serif;
				margin: 0;
			}
			#g {
				height: 20em;
				background-image: linear-gradient(#6078bf, white);
			}
			#bottom {
				height: 14em;
				width: 100%;
			}
			#header1 {
				padding-left: 1em; font-size: 3em; padding-top: 1em;
			}
			#cheader1 {
				padding-left: 1em; font-size: 3em; padding-top: 1em;
			}
			#text1 {
				padding-left: 4em; font-size: 1.2em; padding-top: 1em;
			}
			#code {
			    color: black;
			    background-color: #f9f9f9;
			    border: 1px solid #ddd;
				padding: 1em;
			    line-height: 1.1em;
			    margin-right: 50%;
			    margin-left: 1em;
				margin-top: 1em;
				margin-bottom: 1em;
			    font-size: 0.9em;
			    white-space: pre-wrap;
				font-family: 'Ubuntu Mono', monospace;
			}
			#bytecode {
			    color: black;
			    background-color: #EFF1F8;
			    border: 1px solid #ddd;
				padding-right: 1em;
				padding-left: 1em;
			    line-height: 1.1em;
			    margin-right: 50%;
			    margin-left: 1em;
				margin-top: 1em;
				margin-bottom: 1em;
			    font-size: 0.8em;
			    white-space: pre-wrap;
				font-family: 'Ubuntu Mono', monospace;
			}
			table {
			    color: black;
			    background-color: #EFF1F8;
				padding: 1em;
			    margin-right: 50%;
			    margin-left: 1em;
				margin-top: 1em;
				margin-bottom: 1em;
			    white-space: pre-wrap;
			    border-collapse: collapse;
			}
			td, th {
			  border: 1px solid #26304C;
			  text-align: center;
			  padding: 8px;
			}
			th {
				background-color: #cfd6eb;
			}
			#inlcode {
				color: black;
			    background-color: #f9f9f9;
			    border: 1px solid #ddd;
			    border-radius: 2px;
			    padding: 1px 4px;
			}
			#highlight {
				font-weight: bold;
				text-decoration: underline;
				text-decoration-color: red;
			}
			#subh {
				font-weight: bold;
			}
			div#toc ul {
			  list-style-type: none;
			}
		</style>
	</head>
	<body onload="generateTOC(document.getElementById('toc'));">
		<div id="g">
			<div style="text-align: center; font-size: 6em; padding-top: 2em">LuaJIT Benchmarks</div>
		</div>

		<div id="header1" style="padding-top: 3em;">About</div> <!-- ---------------------------------------------------- -->
		<div id="text1">These benchmark tests demonstrate the changes in LuaJIT performance against the Lua performance.<br>
						LuaJIT stated that globals and locals now has the same performance unlike in plain Lua,<br>
						LuaJIT uses its own interpreter and compiler and many other optimizations to improve the performance. But how was it changed from Lua?<br> 
						First 14 benchmark tests are taken from this page: <a href="https://springrts.com/wiki/Lua_Performance">https://springrts.com/wiki/Lua_Performance</a>.<br>
						New benchmark tests are welcome. <a href="https://github.com/GitSparTV/LuaJIT-Benchmarks/">GitHub Page</a><br>
						Specs: Intel i5-6500 3.20 GHz. 64-bit. LuaJIT 2.1.0-beta3.<br>
						(JIT: ON SSE2 SSE3 SSE4.1 BMI2 fold cse dce fwd dse narrow loop abc sink fuse)
		</div>

		<div id="header1">Benchmark Code</div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<a href="https://github.com/GitSparTV/LuaJIT-Benchmarks/blob/master/bench.lua">Source code</a><br>
			Basically we will use this:<br>
			<div id="code">
for take = 1, 100 do
    local START = os.clock()

    for times = 1, 1000000 do
        ...
    end

    local END = os.clock()
end
			</div>
			For percentage comparison we use the maximum of 100 takes. Average value may be more precise, so make sure to keep that in mind.<br>
			For bytecode and assembly comparison I use <a id="inlcode">luajit -jdump=+Arsa asmbench.lua</a>.<br>
			The total amount of instructions is based on maximum possible amount (Last jump or RET).
			<a href="https://github.com/GitSparTV/LuaJIT-Benchmarks/blob/master/asmbench.lua">Script for bytecode test</a>.
		</div>
		<div id="header1">Contents</div>
		<div id="text1"><div id="toc"></div></div>
		<div id="header1"><div id="ch1">1. Localized variable</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local s = math.sin
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = math.sin(3.14)
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = s(3.14)
			</div>
			<div id="subh">Assembler Results:</div>
			&nbsp;&nbsp;1. Global (_ENV) variable:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;50 instructions total. Diff:
			<div id="bytecode">
mov rsi, 0xfffffffb001761b8		
cmp rsi, [rcx+0x518]		
jnz 0x90e60010        ->0		
cmp dword [rcx+0x514], -0x0c		
jnz 0x90e60010        ->0		
mov ebx, [rcx+0x510]		
cmp dword [rbx+0x1c], +0x1f		
jnz 0x90e60010        ->0		
mov edx, [rbx+0x14]		
mov rsi, 0xfffffffb00176728		
cmp rsi, [rdx+0x230]		
jnz 0x90e60010        ->0		
cmp dword [rdx+0x22c], -0x09		
jnz 0x90e60010        ->0		
cmp dword [rdx+0x228], 0x00176700		
jnz 0x90e60010        ->0
			</div>
			&nbsp;&nbsp;2. Localized variable:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;34 instructions total.
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;The difference is in 16 instructions which is almost nothing. (Fun fact: global variable in plain Lua takes <a id="highlight">0.7s</a>) 
		</div>
		<div id="header1"><div id="ch1">2. Localized method	(3 calls)</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local class = {
    test = function() return 1 end
}
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = class.test()
y = class.test()
z = class.test()
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
local test = class.test
x = test()
y = test()
z = test()
			</div>
			<div id="subh">Bytecode Results:</div>
			&nbsp;&nbsp;1. Direct call:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;26 instructions total. Diff:
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
					<th>Source's value</th>
				</tr>
				<tr>
					<td>UGET</td>
					<td>Set A to upvalue D</td> 
					<td>1	0</td>
					<td>class</td>
				</tr>
				<tr>
					<td>TGETS</td>
					<td>A = B[C] where C is a string</td> 
					<td>1	1	0</td>
					<td>"test"</td>
				</tr>
				<tr>
					<td>UGET</td>
					<td>Set A to upvalue D</td> 
					<td>1	0</td>
					<td>class</td>
				</tr>
				<tr>
					<td>TGETS</td>
					<td>A = B[C] where C is a string</td> 
					<td>1	1	0</td>
					<td>"test"</td>
				</tr>
			</table>
			&nbsp;&nbsp;2. Localized method call:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;25 instructions total. Diff:
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
				</tr>
				<tr>
					<td>MOV</td>
					<td>Copy D to A</td> 
					<td>2	1</td>
				</tr>
				<tr>
					<td>MOV</td>
					<td>Copy D to A</td> 
					<td>2	1</td>
				</tr>
				<tr>
					<td>MOV</td>
					<td>Copy D to A</td> 
					<td>2	1</td>
				</tr>
			</table>
			<div id="subh">Assembler Results:</div>
			&nbsp;&nbsp;1. Direct call:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;58 instructions total.<br>
			&nbsp;&nbsp;2. Localized method call:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;59 instructions total. Diff:
			<div id="bytecode">
cmp ecx, 0x00176e38
			</div>
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;No difference when compiled. <a id="inlcode">MOV</a> should be faster. 
		</div>
		<div id="header1"><div id="ch1">3. Unpack</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local min = math.min
local unpack = unpack
local a = {100, 200, 300, 400}

local function unpack4(a)
    return a[1], a[2], a[3], a[4]
end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = min(a[1], a[2], a[3], a[4])
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = min(unpack(a))
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
x = min(unpack4(a))
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. a[n]: 0.00117 (Min: 0.0003, Average: 0.00042) second(s) (100%)<br>
			&nbsp;&nbsp;2. <a id="highlight">unpack(a): 0.10429 (Min: 0.04729, Average: 0.05921) second(s) (8913.67%)</a><br>
			&nbsp;&nbsp;3. unpack4(a): 0.00296 (Min: 0.0003, Average: 0.00045) second(s) (253.26%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Don't use <a id="inlcode">unpack()</a> when performance matters. (Fun fact: Plain Lua unpack() scored <a id="highlight">1.093s (225%)</a>)
		</div>



		<div id="header1"><div id="ch1">4. Find and return maximum value</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local max = math.max
local num = 100
local y = 0
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = max(num, y)
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
if (num > y) then
    x = num
end
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
x = num > y and num or x
			</div>
			<div id="subh">Bytecode Results:</div>
			&nbsp;&nbsp;1. math.[max/min]:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;11 instructions total. Diff:
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
					<th>Source's value</th>
				</tr>
				<tr>
					<td>UGET</td>
					<td>Set A to upvalue D</td> 
					<td>1	0</td>
					<td>max</td>
				</tr>
				<tr>
					<td>CALL</td>
					<td>Call</td> 
					<td>1	2	3</td>
					<td></td>
				</tr>
				<tr>
					<td>FUNCC</td>
					<td>Pseudo-header for C functions</td> 
					<td></td>
					<td>math.max</td>
				</tr>
			</table>
			&nbsp;&nbsp;2. if [>/<] then:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;11 instructions total. Diff:
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
					<th>Source's value</th>
				</tr>
				<tr>
					<td>ISGE</td>
					<td>Jump if A ≥ D</td> 
					<td>2	1</td>
					<td></td>
				</tr>
				<tr>
					<td>JMP</td>
					<td>Jump</td> 
					<td>1</td>
					<td>=> 0007 (Jumps to the end of the function)</td>
				</tr>
				<tr>
					<td>UGET</td>
					<td>Set A to upvalue D</td> 
					<td>1	0</td>
					<td>num</td>
				</tr>
			</table>
			&nbsp;&nbsp;3. >/< and ... or ...:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;13 instructions total. Diff:
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
					<th>Source's value</th>
				</tr>
				<tr>
					<td>IST</td>
					<td>Jump if D is true</td> 
					<td>1</td>
					<td></td>
				</tr>
				<tr>
					<td>JMP</td>
					<td>Jump</td> 
					<td>2</td>
					<td>=> 0009 (Jumps to "x = result")</td>
				</tr>
			</table>
			<div id="subh">Assembler Results:</div>
			&nbsp;&nbsp;1. math.[max/min]: 34 instructions total.<br>
			&nbsp;&nbsp;2. if [>/<] then: 34 instructions total.<br>
			&nbsp;&nbsp;3. >/< and ... or ...: 34 instructions total.
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Even with localized math.max the amount of instructions is the same (using global math.max will add 16 additional instructions).<br>
			&nbsp;&nbsp;No difference. You can choose anything that suits your code. (Fun fact: Plain Lua max/min are twice slower than >/<)
		</div>

		<div id="header1"><div id="ch1">5. nil check (if vs a or b)</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local y
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
if y == nil then
    x = 1
else
    x = y
end
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = y or 1
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. if nil:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;11 instructions total. Diff:
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
					<th>Source's value</th>
				</tr>
				<tr>
					<td>ISNEP</td>
					<td>Jump if A (var) ≠ D (primitive)</td> 
					<td>1	0</td>
					<td></td>
				</tr>
				<tr>
					<td>JMP</td>
					<td>Jump</td> 
					<td>1</td>
					<td>=> 0009 (Jumps to the end of the function)</td>
				</tr>
			</table>
			&nbsp;&nbsp;2. a or b:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;10 instructions total. Diff:
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
				</tr>
				<tr>
					<td>IST</td>
					<td>Jump if D is true</td> 
					<td>1</td>
				</tr>
			</table>
			<div id="subh">Assembler Results:</div>
			&nbsp;&nbsp;1. if nil: 39 instructions total.<br>
			&nbsp;&nbsp;2. a or b: 39 instructions total.
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;In assembly form they become identical, that is, no difference.<br>
			&nbsp;&nbsp;But, don't forget if <a id="inlcode">a = false</a> and <a id="inlcode">b = true</a>, it chooses <a id="inlcode">b</a>.<br>
			&nbsp;&nbsp;The same is in <a id="inlcode">a and b or c</a>: If <a id="inlcode">a = true</a> but <a id="inlcode">b = false</a> it chooses <a id="inlcode">c</a>.
		</div>

		<div id="header1"><div id="ch1">6. x^2 vs x*x vs math.pow</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local x = 10
local pow = math.pow
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
y = x ^ 2
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
y = x * x
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
y = pow(x, 2)
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. x^2:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;9 instructions total. Diff:
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
				</tr>
				<tr>
					<td>KSHORT</td>
					<td>Set A to 16 bit signed integer D</td> 
					<td>2	2</td>
				</tr>
				<tr>
					<td>POW</td>
					<td>A = B ^ C</td> 
					<td>1	1	2</td>
				</tr>        
			</table>
			&nbsp;&nbsp;2. x*x:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;9 instructions total. Diff:
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
					<th>Source's value</th>
				</tr>
				<tr>
					<td>UGET</td>
					<td>Set A to upvalue D</td> 
					<td>2	0</td>
					<td>x</td>
				</tr>
				<tr>
					<td>MULVV</td>
					<td>A = B * C</td> 
					<td>1	1	2</td>
					<td></td>
				</tr>
			</table>
			&nbsp;&nbsp;3. math.pow:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<a id="highlight">12 instructions total</a>. Diff:
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
					<th>Source's value</th>
				</tr>
				<tr>
					<td>UGET</td>
					<td>Set A to upvalue D</td> 
					<td>1	0</td>
					<td>pow</td>
				</tr>
				<tr>
					<td>KSHORT</td>
					<td>Set A to 16 bit signed integer D</td> 
					<td>3	2</td>
					<td></td>
				</tr>
				<tr>
					<td>CALL</td>
					<td>Call</td> 
					<td>1	2	3</td>
					<td></td>
				</tr>
				<tr>
					<td>FUNCC</td>
					<td>Pseudo-header for C functions</td> 
					<td></td>
					<td>math.pow</td>
				</tr>
			</table>
			<div id="subh">Assembler Results:</div>
			&nbsp;&nbsp;1. x^2: 34 instructions total.<br>
			&nbsp;&nbsp;2. x*x: 34 instructions total.<br>
			&nbsp;&nbsp;3. math.pow: 34 instructions total.
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;No difference when compiled.<br>
			&nbsp;&nbsp;Otherwise use <a id="inlcode">^</a>. math.pow has a function overhead, when 1 and 2 have their own opcodes.<br>
			&nbsp;&nbsp;<a id="inlcode">*</a> operator can be slow because of <a id="inlcode">UGET</a> (<a id="inlcode">^</a> operator has <a id="inlcode">KSHORT</a>). (Fun fact: Plain Lua run x^2 in <a id="highlight">1.422s</a>)
		</div>

		<div id="header1"><div id="ch1">7. math.fmod vs % operator</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local fmod = math.fmod
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = fmod(times, 30) < 1
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = (times % 30) < 1
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. <a id="highlight">math.fmod: 0.06076 (Min: 0.02671, Average: 0.03067) second(s) (446.54%)</a><br>
			&nbsp;&nbsp;2. % operator: 0.01361 (Min: 0.00445, Average: 0.00575) second(s) (100%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Use % for positive numbers.
		</div>

		<div id="header1"><div id="ch1">8. Predefined function or anonymous function in argument</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local func1 = function(a, b, func) return func(a + b) end
local func2 = function(a) return a * 2 end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = func1(1, 2, function(a) return a * 2 end)
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = func1(1, 2, func2)
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. <a id="highlight">Function in argument: 0.11799 (Min: 0.06763, Average: 0.07931) second(s) (12011.59%)</a><br>
			&nbsp;&nbsp;2. Localized function: 0.00098 (Min: 0.0003, Average: 0.00039) second(s) (100%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Anonymous function in argument is insensible in case of single use. Localize it in case of multiple use. (Fun fact: Plain Lua scored <a id="highlight">3.890s</a> with the first code)
		</div>

		<div id="header1"><div id="ch1">9. for loops</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local a = {}

for i = 1, 100 do
    a[#a + 1] = i
end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
for k, v in pairs(a) do
    x = v
end
			</div>
			<div id="subh">Code 2 (Using <a href="https://github.com/LuaJIT/LuaJIT/pull/275">JIT-ed next</a>):</div>
			<div id="code">
for k, v in pairs(a) do
    x = v
end
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
for k, v in ipairs(a) do
    x = v
end
			</div>
			<div id="subh">Code 4:</div>
			<div id="code">
for i = 1, 100 do
    x = a[i]
end
			</div>
			<div id="subh">Code 5:</div>
			<div id="code">
for i = 1, #a do
    x = a[i]
end
			</div>
			<div id="subh">Code 6:</div>
			<div id="code">
local length = #a

for i = 1, length do
    x = a[i]
end
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. <a id="highlight">pairs(a): 1.3537 (Min: 0.78992, Average: 0.94855) second(s) (1106.7%)</a><br>
			&nbsp;&nbsp;2. pairs(a) with <a href="https://github.com/LuaJIT/LuaJIT/pull/275">JIT-ed next</a>: 1.05089 (Min: 0.71751, Average: 0.77965) second(s) (859.20%)<br>
			&nbsp;&nbsp;3. ipairs(a): 0.24878 (Min: 0.12709, Average: 0.14934) second(s) (203.40%)<br>
			&nbsp;&nbsp;4. Known length: 0.12231 (Min: 0.08351, Average: 0.08955) second(s) (100%)<br>
			&nbsp;&nbsp;5. #a: 0.18397 (Min: 0.1006, Average: 0.12254) second(s) (150.41%)<br>
			&nbsp;&nbsp;6. local len = #a: 0.29334 (Min: 0.10269, Average: 0.12108) second(s) (239.83%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Try to use array instead of hashtable. If you know the exact size, localize #a. Don't use pairs for sequential arrays.
		</div>
		<div id="header1"><div id="ch1">10. a[x] vs a.x</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local a = {
    foo = "bar"
}
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = a["foo"]
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = a.foo
			</div>
			<div id="subh">Bytecode Results:</div>
			&nbsp;&nbsp;1. a[x]: 8 instructions total.<br>
			&nbsp;&nbsp;2. a.x: 8 instructions total.<br>
			<div id="subh">Assembler Results:</div>
			&nbsp;&nbsp;1. a[x]: 49 instructions total.<br>
			&nbsp;&nbsp;2. a.x: 49 instructions total.<br>
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;No difference.<br>
			&nbsp;&nbsp;<a id="inlcode">.x</a> is a syntactic sugar of <a id="inlcode">[x]</a>, so in bytecode they both are <a id="inlcode">TGETS</a> (A = B[C] where C is string).
		</div>

		<div id="header1"><div id="ch1">11. Localizing table value for multiple uses</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local a = {}

for i = 1, 100 do
    a[#a + 1] = {
        x = 10
    }
end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
for n = 1, 100 do
    a[n].x = a[n].x + 1
end
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
for n = 1, 100 do
    local y = a[n]
    y.x = y.x + 1
end
			</div>
			<div id="subh">Bytecode Results:</div>
			&nbsp;&nbsp;1. a[n] & a[n]:<br>
			&nbsp;&nbsp;8 instructions total. Diff:
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
					<th>Source's value</th>
				</tr>
				<tr>
					<td>UGET</td>
					<td>Set A to upvalue D</td> 
					<td>5	0</td>
					<td>a</td>
				</tr>
				<tr>
					<td>TGETV</td>
					<td>A = B[C] where C is a usual variable</td> 
					<td>5	5	4</td>
					<td></td>
				</tr>
			</table>
			&nbsp;&nbsp;2. local y = a[n] & y & y:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;6 instructions total.
			<div id="subh">Assembler Results:</div>
			&nbsp;&nbsp;1. a[n] & a[n]:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;54 instructions total. Diff:
			<div id="bytecode">
cmp ebx, +0x38		
jbe 0x90e60010        ->0
			</div>
			&nbsp;&nbsp;2. local y = a[n] & y & y:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;52 instructions total.
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;No difference. Localizing a[n] saves your 2 instructions, one of them is jump (jbe).
		</div>

		<div id="header1"><div id="ch1">12. Array insertion</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local a = {}
local tinsert = table.insert
local count = 1
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
tinsert(a, times)
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
tinsert(a, 1, times)
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
a[times] = times
			</div>
			<div id="subh">Code 4:</div>
			<div id="code">
a[#a + 1] = times
			</div>
			<div id="subh">Code 5:</div>
			<div id="code">
a[count] = times
count = count + 1
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. <a id="highlight">tinsert: 0.18298 (Min: 0.10624, Average: 0.12044) second(s) (500.62%)</a><br>
			&nbsp;&nbsp;2. <a id="highlight">tinsert at index 1: 835.05418 (Min: 661.96379, Average: 705.36165) second(s) (2284689.95%)</a><br>
			&nbsp;&nbsp;3. a[times]: 0.03655 (Min: 0.01016, Average: 0.01547) second(s) (100%)<br>
			&nbsp;&nbsp;4. a[#a + 1]: 0.18138 (Min: 0.10908, Average: 0.12436) second(s) (496.25%)<br>
			&nbsp;&nbsp;5. a[count] & count++: 0.23939 (Min: 0.07798, Average: 0.14459) second(s) (654.96%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Try to use the `i` from the for loop or a[#a + 1].
		</div>

		<div id="header1"><div id="ch1">13. Table with and without pre-allocated size</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local a
require("table.new")
local new = table.new
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
a = {}
a[1] = 1
a[2] = 2
a[3] = 3
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
a = {true, true, true}
a[1] = 1
a[2] = 2
a[3] = 3
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
a = new(3,0)
a[1] = 1
a[2] = 2
a[3] = 3
			</div>
			<div id="subh">Code 4:</div>
			<div id="code">
a = {1, 2, 3}
			</div>
			<div id="subh">Code 5 (FFI):</div>
			<div id="code">
a = ffi.new("int[3]", 1, 2, 3)
			</div>
			<div id="subh">Code 6 (FFI):</div>
			<div id="code">
a = ffi.new("int[3]")
a[0] = 1
a[1] = 2
a[2] = 3
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. <a id="highlight">Allocated on demand: 0.25558 (Min: 0.16433, Average: 0.18059) second(s) (11209.64%)</a><br>
			&nbsp;&nbsp;2. Pre-allocated with dummy values: 0.00327 (Min: 0.00061, Average: 0.00095) second(s) (143.42%)<br>
			&nbsp;&nbsp;3. <a id="highlight">Pre-allocated by table.new: 0.10373 (Min: 0.04809, Average: 0.05792) second(s) (4549.56%)</a><br>
			&nbsp;&nbsp;4. Defined in constructor: 0.0031 (Min: 0.00061, Average: 0.00093) second(s) (135.96%)<br>
			&nbsp;&nbsp;5. (FFI) Defined in constructor: 0.00228 (Min: 0.00062, Average: 0.00087) second(s) (100%)<br>
			&nbsp;&nbsp;6. (FFI) Defined after: 0.00403 (Min: 0.00061, Average: 0.0009) second(s) (176.75%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Pre-allocate table size for better performance.
		</div>

		<div id="header1"><div id="ch1">14. Table initialization before or each time on insertion</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
T = {}
local CachedTable = {"abc", "def", "ghk"}
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
T[times] = CachedTable
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
T[times] = {"abc", "def", "ghk"}
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. Cached table for all insertion: 0.00356 (Min: 0.00098, Average: 0.00162) second(s) (100%)<br>
			&nbsp;&nbsp;2. <a id="highlight">Table constructor for each insertion: 0.07934 (Min: 0.02153, Average: 0.0256) second(s) (2229.13%)</a>
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;If you use the same table/userdata/function multiple times cache it and reuse every time. (For example Color object in Garry's Mod)
		</div>

		<div id="header1"><div id="ch1">15. String split (by character)</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local text = "Hello, this is an example text"
local cstring = ffi.cast("const char*", text)
local char = string.char

local gsubfunc = function(s)
    x = s
end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
for i = 1, #text do
    x = text:sub(i, i)
end
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
for k in string.gmatch(text, ".") do
    x = k
end
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
string.gsub(text, ".", gsubfunc)
			</div>
			<div id="subh">Code 4 (FFI):</div>
			<div id="code">
for i = 0, #text - 1 do
    x = char(cstring[i])
end
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. sub(1,1): 0.43051 (Min: 0.31354, Average: 0.33679) second(s) (100%)<br>
			&nbsp;&nbsp;2. <a id="highlight">gmatch with ".": 2.8014 (Min: 1.87609, Average: 2.13029) second(s) (650.71%)</a><br>
			&nbsp;&nbsp;3. <a id="highlight">gsub with "." and cached function: 3.04491 (Min: 2.37368, Average: 2.54034) second(s) (707.27%)</a></br>
			&nbsp;&nbsp;4. (FFI) Predefined const char* array: 0.60989 (Min: 0.34236, Average: 0.39011) second(s) (141.66%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;string.sub is ok for string splitting. Patterns deal huge impact on performance.
		</div>

		<div id="header1"><div id="ch1">16. Empty string check</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local s = ""
local cstring = ffi.cast("const char*", s)
ffi.cdef([[
    size_t strlen ( const char * str );
]])
local C = ffi.C
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
y = #s == 0
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
y = s == ""
			</div>
			<div id="subh">Code 3 (FFI):</div>
			<div id="code">
y = cstring[0] == 0
			</div>
			<div id="subh">Code 4 (FFI):</div>
			<div id="code">
y = C.strlen(cstring) == 0
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. len == 0: 0.00534 (Min: 0.0003, Average: 0.00062) second(s) (120.27%)<br>
			&nbsp;&nbsp;2. str == "": 0.00538 (Min: 0.0003, Average: 0.00077) second(s) (121.17%)<br>
			&nbsp;&nbsp;3. (FFI) y = cstring[0] == 0: 0.00444 (Min: 0.0003, Average: 0.00054) second(s) (100%)<br>
			&nbsp;&nbsp;4. (FFI) <a id="highlight">y = C.strlen(cstring) == 0: 0.01422 (Min: 0.00202, Average: 0.00323) second(s) (320.27%)</a>
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;No difference for Lua strings. Use the second syntax if you don't know the value type. If you use FFI consider using array indexing.<br>
			&nbsp;&nbsp;Remember, length of strings like <a id="inlcode">\0hello</a> will return 6 as Lua string but 0 by strlen.
		</div>
		<div id="header1"><div id="ch1">17. C array size (FFI)</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
new = ffi.new
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = new("const char*[16]")
x1 = new("const char*[1024]")
x2 = new("int[16]")
x3 = new("int[1024]")
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = new("const char*[?]", 16)
x1 = new("const char*[?]", 1024)
x2 = new("int[?]", 16)
x3 = new("int[?]", 1024)
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. [n]: 3.71268 (Min: 2.55459, Average: 2.91652) second(s) (100%)<br>
			&nbsp;&nbsp;2. VLA: 4.13164 (Min: 2.32921, Average: 2.89719) second(s) (111.28%)<br>
			
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Both of them are ok.</br>
			&nbsp;&nbsp;Note from NYI: ffi.new is partially compiled in 2.1: Not for non-default init of VLA/VLS or > 128 bytes or > 16 array elements.
		</div>
		<div id="header1"><div id="ch1">18. String concatenation</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local s, d
local bs = string.rep("----------", 1000)
local t = {bs, bs, bs, bs, bs, bs, bs, bs, bs, bs}

-- I use this function to make sure that LuaJIT doesn't skip the iteration.
local function use(_)
    d = _
end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
s = bs .. bs .. bs .. bs .. bs .. bs .. bs .. bs .. bs .. bs
use(s)
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
s = bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
use(s)
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
s = bs

for i = 1, 9 do
    s = s .. bs
end

use(s)
			</div>
			<div id="subh">Code 4:</div>
			<div id="code">
s = table.concat(t)
use(s)
			</div>
			<div id="subh">Code 5:</div>
			<div id="code">
s = string.format("%s%s%s%s%s%s%s%s%s%s", bs, bs, bs, bs, bs, bs, bs, bs, bs, bs)
use(s)
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. All concatenations at once: 0.00242 (Min: 0.0003, Average: 0.00054) second(s) (100%)<br>
			&nbsp;&nbsp;2. Separate concatenations in a row: 0.00766 (Min: 0.0003, Average: 0.00051) second(s) (316.52%)<br>
			&nbsp;&nbsp;3. <a id="highlight">Separate concatenations in loop: 90.73938 (Min: 74.0794, Average: 77.69551) second(s) (3749561.15%)</a><br>
			&nbsp;&nbsp;4. table.concat: 20.74941 (Min: 16.40618, Average: 17.86198) second(s) (857413.63%)<br>
			&nbsp;&nbsp;5. string.format: 0.01353 (Min: 0.0003, Average: 0.00068) second(s) (559.09%)<br>
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp; table.concat should be used in places where concatenation can't be optimized by LuaJIT.
		</div>
		<div id="header1"><div id="ch1">19. Constant variables in functions</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local TYPE_bool = "bool"
function isbool1(b)
    return type(b) == "bool"
end

function isbool2(b)
    return type(b) == TYPE_bool
end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = isbool1(false)
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = isbool2(false)
			</div>
			<div id="subh">Bytecode Results:</div>
			&nbsp;&nbsp;1. isbool1:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;19 instructions total.
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
					<th>Source's value</th>
				</tr>
				<tr>
					<td>Jump if A (var) = D (str)</td> 
					<td>ISEQS</td>
					<td>1	1</td>
					<td>"bool"</td>
				</tr>
			</table>
			&nbsp;&nbsp;2. isbool2:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;20 instructions total.
			<table>
				<tr>
					<th>Instruction</th> 
					<th>Description of instruction</th>
					<th>Operands</th>
					<th>Source's value</th>
				</tr>
				<tr>
					<td>Set A to upvalue D</td> 
					<td>UGET</td>
					<td>2	0</td>
					<td>TYPE_bool</td>
				</tr>
				<tr>
					<td>Jump if A (var) = D (var)</td> 
					<td>ISEQV</td>
					<td>1	2</td>
					<td></td>
				</tr>
			</table>
			<div id="subh">Bytecode Results:</div>
			&nbsp;&nbsp;1. isbool1: 51 instructions total.<br>
			&nbsp;&nbsp;2. isbool2: 51 instructions total.
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Both functions has the same amount of operations when compiled.<br>
			&nbsp;&nbsp;If we look at the bytecode, we can see that <a id="inlcode">isbool2</a> requires to take the upvalue and compare it as <a id="inlcode">var to var</a> when <a id="inlcode">isbool1</a> takes string constant and uses <a id="inlcode">ISEQS</a> (var to str) which may be more efficient for string comparison.<br>
			&nbsp;&nbsp;I prefer <a id="inlcode">isbool1</a>.
		</div>
		<div id="bottom">
			<div style="text-align: center; font-size: 1.5em; padding-top: 2.5em">
			<img src="http://hits.dwyl.io/GitSparTV/LuaJIT-Benchmarks/index.html.svg"><br>
			Made by Spar (Spar#6665)<br>
			New benchmark tests are welcome. <a href="https://github.com/GitSparTV/LuaJIT-Benchmarks/">GitHub Page</a><br>
			Public Domain<br>
			2019
			</div>
		</div>
	</body>
</html>