<html>
	<head>
		<link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
		<title>LuaJIT Benchmark Tests</title>
		<meta name="description" content="LuaJIT Benchmark tests page. Made for understanding the results and for optimization solutions.">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="keywords" content="Lua, LuaJIT, benchmark, benchmark tests, performance, LuaJIT vs Lua, LuaJIT performance, Lua performance">
		<script src="toc.js" type="text/javascript"></script>
		<style type="text/css">
			body {
				font-family: 'Roboto', sans-serif;
				margin: 0;
			}
			#g {
				height: 20em;
				background-image: linear-gradient(#6078bf, white);
			}
			#bottom {
				height: 14em;
				width: 100%;
			}
			#header1 {
				padding-left: 1em; font-size: 3em; padding-top: 1em;
			}
			#cheader1 {
				padding-left: 1em; font-size: 3em; padding-top: 1em;
			}
			#text1 {
				padding-left: 4em; font-size: 1.2em; padding-top: 1em;
			}
			#code {
			    color: black;
			    background-color: #f9f9f9;
			    border: 1px solid #ddd;
				padding: 1em;
			    line-height: 1.1em;
			    margin-right: 50%;
			    margin-left: 1em;
				margin-top: 1em;
				margin-bottom: 1em;
			    font-size: 1em;
			    white-space: pre-wrap;
			}
			#inlcode {
				color: black;
			    background-color: #f9f9f9;
			    border: 1px solid #ddd;
			    border-radius: 2px;
			    padding: 1px 4px;
			}
			#highlight {
				font-weight: bold;
				text-decoration: underline;
				text-decoration-color: red;
			}
			#subh {
				font-weight: bold;
			}
			div#toc ul {
			  list-style-type: none;
			}
		</style>
	</head>
	<body onload="generateTOC(document.getElementById('toc'));">
		<div id="g">
			<div style="text-align: center; font-size: 6em; padding-top: 2em">LuaJIT Benchmarks</div>
		</div>

		<div id="header1" style="padding-top: 3em;">About</div> <!-- ---------------------------------------------------- -->
		<div id="text1">These benchmark tests demonstrate the changes in LuaJIT performance against the Lua performance.<br>
						LuaJIT stated that globals and locals now has the same performance unlike in plain Lua,<br>
						LuaJIT uses its own interpreter and compiler and many other optimizations to improve the performance. But how was it changed from Lua?<br> 
						First 14 benchmark tests are taken from this page: <a href="https://springrts.com/wiki/Lua_Performance">https://springrts.com/wiki/Lua_Performance</a>.<br>
						New benchmark tests are welcome. <a href="https://github.com/GitSparTV/LuaJIT-Benchmarks/">GitHub Page</a><br>
						Specs: Intel i5-6500 3.20 GHz. 64-bit. LuaJIT 2.1.0-beta3.<br>
						(JIT: ON SSE2 SSE3 SSE4.1 BMI2 fold cse dce fwd dse narrow loop abc sink fuse)
		</div>

		<div id="header1">Benchmark Code</div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<a href="https://github.com/GitSparTV/LuaJIT-Benchmarks/blob/master/bench.lua">Source code</a><br>
		Basically we will use this:<br>
		<div id="code">
for take = 1, 100 do
	local START = os.clock()

	for times = 1, 1000000 do
		...
	end

	local END = os.clock()
end
		</div>
	For percentage comparison we use the maximum of 100 takes. Average value may be more precise, so make sure to keep that in mind.</div>
		<div id="header1">Contents</div>
		<div id="text1"><div id="toc"></div></div>
		<div id="header1"><div id="ch1">1. Localized variable</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local s = math.sin
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = math.sin(3.14)
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = s(3.14)
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. Global / _ENV variable: 0.00099 (Min: 0.00029, Average: 0.00039) second(s) (102.17%)<br>
			&nbsp;&nbsp;2. Localized variable: 0.00097 (Min: 0.0003, Average: 0.00038) second(s) (100%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;No difference. (Fun fact: global variable in plain Lua takes <a id="highlight">0.7s</a>) 
		</div>

		<div id="header1"><div id="ch1">2. Localized method	(3 calls)</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local class = {
	test = function() return 1 end
}
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
for i = 1, 5000 do
	x = class.test()
	y = class.test()
	z = class.test()
end
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
for i = 1, 5000 do
	local test = class.test
	x = test()
	y = test()
	z = test()
end
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. Direct call: 2.10904 (Min: 1.72025, Average: 1.7977) second(s) (100%)<br>
			&nbsp;&nbsp;2. Localized method call: 2.10936 (Min: 1.69758, Average: 1.81756) second(s) (100.01%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;No difference.
		</div>
		<div id="header1"><div id="ch1">3. Unpack</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local min = math.min
local unpack = unpack
local a = {100, 200, 300, 400}

local function unpack4(a)
	return a[1], a[2], a[3], a[4]
end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = min(a[1], a[2], a[3], a[4])
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = min(unpack(a))
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
x = min(unpack4(a))
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. a[n]: 0.00117 (Min: 0.0003, Average: 0.00042) second(s) (100%)<br>
			&nbsp;&nbsp;2. <a id="highlight">unpack(a): 0.10429 (Min: 0.04729, Average: 0.05921) second(s) (8913.67%)</a><br>
			&nbsp;&nbsp;3. unpack4(a): 0.00296 (Min: 0.0003, Average: 0.00045) second(s) (253.26%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Don't use <a id="inlcode">unpack()</a> when performance matters. (Fun fact: Plain Lua unpack() scored <a id="highlight">1.093s (225%)</a>)
		</div>



		<div id="header1"><div id="ch1">4. Find and return maximum value</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local max = math.max
local num = 100
local y = 0
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
for i = 1,5000 do
	x = max(num, y)
end
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
for i = 1,5000 do
	if (num > y) then
		x = num
	end
end
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
for i = 1,5000 do
	x = num > y and num or x
end
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. math.[max/min]: 1.96412 (Min: 1.68282, Average: 1.76018) second(s) (100%)<br>
			&nbsp;&nbsp;2. if [>/<] then: 2.34396 (Min: 1.70205, Average: 1.81333) second(s) (119.33%)<br>
			&nbsp;&nbsp;3. >/< and ... or ...: 2.19993 (Min: 1.70727, Average: 1.8106) second(s) (112%)




			<div id="subh">Conclusion:</div>
			&nbsp;Depends on situation, both are ok. (Fun fact: Plain Lua has the opposite results: max/min are twice slower than >/<)
		</div>

		<div id="header1"><div id="ch1">5. nil check (if vs a or b)</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Code 1:</div>
			<div id="code">
for i = 1, 1000 do
	local y

	if (y == nil) then
		x = 1
	else
		x = y
	end
end
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
for i = 1, 1000 do
	local y
	x = y or 1
end
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. if nil: 0.52687 (Min: 0.3491, Average: 0.37962) second(s) (129.15%)<br>
			&nbsp;&nbsp;2. a or b: 0.40793 (Min: 0.34957, Average: 0.36266) second(s) (100%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;No difference. 
		</div>

		<div id="header1"><div id="ch1">6. x^2 vs x*x</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local x = 10
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
for i = 1, 1000 do
	y = x ^ 2
end
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
for i = 1, 1000 do
	y = x * x
end
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
for i = 1, 1000 do
	y = math.pow(x, 2)
end
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. x^2: 0.38873 (Min: 0.34823, Average: 0.36186) second(s) (101.56%)<br>
			&nbsp;&nbsp;2. x*x: 0.38273 (Min: 0.35423, Average: 0.36342) second(s) (100%)<br>
			&nbsp;&nbsp;3. <a id="highlight">math.pow: 3.56163 (Min: 2.04571, Average: 2.18397) second(s) (930.58%)</a>

			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;math.pow probably has a function overhead. <!-- (Fun fact: Plain Lua run x^2 in <a id="highlight">1.422s</a>) -->
		</div>

		<div id="header1"><div id="ch1">7. math.fmod vs % operator</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local fmod = math.fmod
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = fmod(times, 30) < 1
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = (times % 30) < 1
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. <a id="highlight">math.fmod: 0.06076 (Min: 0.02671, Average: 0.03067) second(s) (446.54%)</a><br>
			&nbsp;&nbsp;2. % operator: 0.01361 (Min: 0.00445, Average: 0.00575) second(s) (100%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Use % for positive numbers.
		</div>

		<div id="header1"><div id="ch1">8. Predefined function or anonymous function in argument</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local func1 = function(a, b, func) return func(a + b) end
local func2 = function(a) return a * 2 end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = func1(1, 2, function(a) return a * 2 end)
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = func1(1, 2, func2)
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. <a id="highlight">Function in argument: 0.11799 (Min: 0.06763, Average: 0.07931) second(s) (12011.59%)</a><br>
			&nbsp;&nbsp;2. Localized function: 0.00098 (Min: 0.0003, Average: 0.00039) second(s) (100%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Anonymous function in argument is insensible in case of single use. Localize it in case of multiple use. (Fun fact: Plain Lua scored <a id="highlight">3.890s</a> with the first code)
		</div>

		<div id="header1"><div id="ch1">9. for loops</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local a = {}

for i = 1, 100 do
	a[#a + 1] = i
end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
for k, v in pairs(a) do
	x = v
end
			</div>
			<div id="subh">Code 2 (Using <a href="https://github.com/LuaJIT/LuaJIT/pull/275">JIT-ed next</a>):</div>
			<div id="code">
for k, v in pairs(a) do
	x = v
end
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
for k, v in ipairs(a) do
	x = v
end
			</div>
			<div id="subh">Code 4:</div>
			<div id="code">
for i = 1, 100 do
	x = a[i]
end
			</div>
			<div id="subh">Code 5:</div>
			<div id="code">
for i = 1, #a do
	x = a[i]
end
			</div>
			<div id="subh">Code 6:</div>
			<div id="code">
local length = #a

for i = 1, length do
	x = a[i]
end
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. <a id="highlight">pairs(a): 1.3537 (Min: 0.78992, Average: 0.94855) second(s) (1106.7%)</a><br>
			&nbsp;&nbsp;2. pairs(a) with <a href="https://github.com/LuaJIT/LuaJIT/pull/275">JIT-ed next</a>: 1.05089 (Min: 0.71751, Average: 0.77965) second(s) (859.20%)<br>
			&nbsp;&nbsp;3. ipairs(a): 0.24878 (Min: 0.12709, Average: 0.14934) second(s) (203.40%)<br>
			&nbsp;&nbsp;4. Known length: 0.12231 (Min: 0.08351, Average: 0.08955) second(s) (100%)<br>
			&nbsp;&nbsp;5. #a: 0.18397 (Min: 0.1006, Average: 0.12254) second(s) (150.41%)<br>
			&nbsp;&nbsp;6. local len = #a: 0.29334 (Min: 0.10269, Average: 0.12108) second(s) (239.83%)
			<div id="subh">Conclusion:</div>





			&nbsp;&nbsp;Try to use array instead of hashtable. If you know the exact size, localize #a. Don't use pairs for sequential arrays.
		</div>
		<div id="header1"><div id="ch1">10. a[x] vs a.x</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local a = {
	foo = "bar"
}
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = a["foo"]
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = a.foo
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. a[x]: 0.0023 (Min: 0.0003, Average: 0.00055) second(s) (100%)<br>
			&nbsp;&nbsp;2. a.x: 0.01169 (Min: 0.0003, Average: 0.00067) second(s) (509.23%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;No difference.
		</div>

		<div id="header1"><div id="ch1">11. Localizing table value for multiple uses</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local a = {}

for i = 1, 100 do
	a[#a + 1] = {
		x = 10
	}
end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
for n = 1, 100 do
	a[n].x = a[n].x + 1
end
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
for n = 1, 100 do
	local y = a[n]
	y.x = y.x + 1
end
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. a[n] & a[n]: 0.27431 (Min: 0.18345, Average: 0.1958) second(s) (100%)<br>
			&nbsp;&nbsp;2. <a id="highlight">local y = a[n] & y & y: 0.33419 (Min: 0.17806, Average: 0.21874) second(s) (121.83%)</a>
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Sometimes localization is not important
		</div>

		<div id="header1"><div id="ch1">12. Array insertion</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local a = {}
local tinsert = table.insert
local count = 1
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
tinsert(a, times)
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
tinsert(a, 1, times)
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
a[times] = times
			</div>
			<div id="subh">Code 4:</div>
			<div id="code">
a[#a + 1] = times
			</div>
			<div id="subh">Code 5:</div>
			<div id="code">
a[count] = times
count = count + 1
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. <a id="highlight">tinsert: 0.18298 (Min: 0.10624, Average: 0.12044) second(s) (500.62%)</a><br>
			&nbsp;&nbsp;2. <a id="highlight">tinsert at index 1: 835.05418 (Min: 661.96379, Average: 705.36165) second(s) (2284689.95%)</a><br>
			&nbsp;&nbsp;3. a[times]: 0.03655 (Min: 0.01016, Average: 0.01547) second(s) (100%)<br>
			&nbsp;&nbsp;4. a[#a + 1]: 0.18138 (Min: 0.10908, Average: 0.12436) second(s) (496.25%)<br>
			&nbsp;&nbsp;5. a[count] & count++: 0.23939 (Min: 0.07798, Average: 0.14459) second(s) (654.96%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Try to use the `i` from the for loop or a[#a + 1].
		</div>

		<div id="header1"><div id="ch1">13. Table with and without pre-allocated size</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local a
require("table.new")
local new = table.new
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
a = {}
a[1] = 1
a[2] = 2
a[3] = 3
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
a = {true, true, true}
a[1] = 1
a[2] = 2
a[3] = 3
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
a = new(3,0)
a[1] = 1
a[2] = 2
a[3] = 3
			</div>
			<div id="subh">Code 4:</div>
			<div id="code">
a = {1, 2, 3}
			</div>
			<div id="subh">Code 5 (FFI):</div>
			<div id="code">
a = ffi.new("int[3]", 1, 2, 3)
			</div>
			<div id="subh">Code 6 (FFI):</div>
			<div id="code">
a = ffi.new("int[3]")
a[0] = 1
a[1] = 2
a[2] = 3
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. <a id="highlight">Allocated on demand: 0.25558 (Min: 0.16433, Average: 0.18059) second(s) (11209.64%)</a><br>
			&nbsp;&nbsp;2. Pre-allocated with dummy values: 0.00327 (Min: 0.00061, Average: 0.00095) second(s) (143.42%)<br>
			&nbsp;&nbsp;3. <a id="highlight">Pre-allocated by table.new: 0.10373 (Min: 0.04809, Average: 0.05792) second(s) (4549.56%)</a><br>
			&nbsp;&nbsp;4. Defined in constructor: 0.0031 (Min: 0.00061, Average: 0.00093) second(s) (135.96%)<br>
			&nbsp;&nbsp;5. (FFI) Defined in constructor: 0.00228 (Min: 0.00062, Average: 0.00087) second(s) (100%)<br>
			&nbsp;&nbsp;6. (FFI) Defined after: 0.00403 (Min: 0.00061, Average: 0.0009) second(s) (176.75%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Pre-allocate table size for better performance.
		</div>

		<div id="header1"><div id="ch1">14. Table initialization before or each time on insertion</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
T = {}
local CachedTable = {"abc", "def", "ghk"}
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
T[times] = CachedTable
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
T[times] = {"abc", "def", "ghk"}
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. Cached table for all insertion: 0.00356 (Min: 0.00098, Average: 0.00162) second(s) (100%)<br>
			&nbsp;&nbsp;2. <a id="highlight">Table constructor for each insertion: 0.07934 (Min: 0.02153, Average: 0.0256) second(s) (2229.13%)</a>
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;If you use the same table/userdata/function multiple times cache it and reuse every time. (For example Color object in Garry's Mod)
		</div>

		<div id="header1"><div id="ch1">15. String split (by character)</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local text = "Hello, this is an example text"
local cstring = ffi.cast("const char*", text)
local char = string.char

local gsubfunc = function(s)
	x = s
end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
for i = 1, #text do
	x = text:sub(i, i)
end
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
for k in string.gmatch(text, ".") do
	x = k
end
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
string.gsub(text, ".", gsubfunc)
			</div>
			<div id="subh">Code 4 (FFI):</div>
			<div id="code">
for i = 0, #text - 1 do
	x = char(cstring[i])
end
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. sub(1,1): 0.43051 (Min: 0.31354, Average: 0.33679) second(s) (100%)<br>
			&nbsp;&nbsp;2. <a id="highlight">gmatch with ".": 2.8014 (Min: 1.87609, Average: 2.13029) second(s) (650.71%)</a><br>
			&nbsp;&nbsp;3. <a id="highlight">gsub with "." and cached function: 3.04491 (Min: 2.37368, Average: 2.54034) second(s) (707.27%)</a></br>
			&nbsp;&nbsp;4. (FFI) Predefined const char* array: 0.60989 (Min: 0.34236, Average: 0.39011) second(s) (141.66%)
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;string.sub is ok for string splitting. Patterns deal huge impact on performance.
		</div>

		<div id="header1"><div id="ch1">16. Empty string check</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local s = ""
local cstring = ffi.cast("const char*", s)
ffi.cdef([[
	size_t strlen ( const char * str );
]])
local C = ffi.C
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
y = #s == 0
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
y = s == ""
			</div>
			<div id="subh">Code 3 (FFI):</div>
			<div id="code">
y = cstring[0] == 0
			</div>
			<div id="subh">Code 4 (FFI):</div>
			<div id="code">
y = C.strlen(cstring) == 0
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. len == 0: 0.00534 (Min: 0.0003, Average: 0.00062) second(s) (100%)<br>
			&nbsp;&nbsp;2. str == "": 0.00538 (Min: 0.0003, Average: 0.00077) second(s) (100.74%)<br>
			&nbsp;&nbsp;3. (FFI) y = cstring[0] == 0: 0.00444 (Min: 0.0003, Average: 0.00054) second(s) (83.14%)<br>
			&nbsp;&nbsp;4. (FFI) <a id="highlight">y = C.strlen(cstring) == 0: 0.01422 (Min: 0.00202, Average: 0.00323) second(s) (266.29%)</a>
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;No difference for Lua strings. Use the second syntax if you don't know the value type. If you use FFI consider using array indexing.
		</div>
		<div id="header1"><div id="ch1">17. C array size (FFI)</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
new = ffi.new
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
x = new("const char*[16]")
x1 = new("const char*[1024]")
x2 = new("int[16]")
x3 = new("int[1024]")
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
x = new("const char*[?]", 16)
x1 = new("const char*[?]", 1024)
x2 = new("int[?]", 16)
x3 = new("int[?]", 1024)
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. [n]: 3.71268 (Min: 2.55459, Average: 2.91652) second(s) (100%)<br>
			&nbsp;&nbsp;2. VLA: 4.13164 (Min: 2.32921, Average: 2.89719) second(s) (111.28%)<br>
			
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp;Both of them are ok.</br>
			&nbsp;&nbsp;Note from NYI: ffi.new is partially compiled in 2.1: Not for non-default init of VLA/VLS or > 128 bytes or > 16 array elements.
		</div>
		<div id="header1"><div id="ch1">18. String concatenation</div></div> <!-- ---------------------------------------------------- -->
		<div id="text1">
			<div id="subh">Predefines:</div>
			<div id="code">
local s, d
local bs = string.rep("----------", 1000)
local t = {bs, bs, bs, bs, bs, bs, bs, bs, bs, bs}

-- I use this function to make sure that LuaJIT doesn't skip the iteration.
local function use(_)
	d = _
end
			</div>
			<div id="subh">Code 1:</div>
			<div id="code">
s = bs .. bs .. bs .. bs .. bs .. bs .. bs .. bs .. bs .. bs
use(s)
			</div>
			<div id="subh">Code 2:</div>
			<div id="code">
s = bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
s = s .. bs
use(s)
			</div>
			<div id="subh">Code 3:</div>
			<div id="code">
s = bs
for i=1,9 do
	s = s .. bs
end
use(s)
			</div>
			<div id="subh">Code 4:</div>
			<div id="code">
s = table.concat(t)
use(s)
			</div>
			<div id="subh">Code 5:</div>
			<div id="code">
s = string.format("%s%s%s%s%s%s%s%s%s%s", bs, bs, bs, bs, bs, bs, bs, bs, bs, bs)
use(s)
			</div>
			<div id="subh">Results:</div>
			&nbsp;&nbsp;1. All concatenations at once: 0.00242 (Min: 0.0003, Average: 0.00054) second(s) (100%)<br>
			&nbsp;&nbsp;2. Separate concatenations: 0.00766 (Min: 0.0003, Average: 0.00051) second(s) (316.52%)<br>
			&nbsp;&nbsp;3. <a id="highlight">Separate concatenations in loop: 90.73938 (Min: 74.0794, Average: 77.69551) second(s) (3749561.15%)</a><br>
			&nbsp;&nbsp;4. table.concat: 20.74941 (Min: 16.40618, Average: 17.86198) second(s) (857413.63%)<br>
			&nbsp;&nbsp;5. string.format: 0.01353 (Min: 0.0003, Average: 0.00068) second(s) (559.09%)<br>
			<div id="subh">Conclusion:</div>
			&nbsp;&nbsp; table.concat should be used in places where concatenation can't be optimized by LuaJIT.
		</div>
		<div id="bottom">
			<div style="text-align: center; font-size: 1.5em; padding-top: 2.5em">
			<img src="http://hits.dwyl.io/GitSparTV/LuaJIT-Benchmarks/index.html.svg"><br>
			Made by Spar (Spar#6665)<br>
			New benchmark tests are welcome. <a href="https://github.com/GitSparTV/LuaJIT-Benchmarks/">GitHub Page</a><br>
			Public Domain<br>
			2019
			</div>
		</div>
	</body>
</html>